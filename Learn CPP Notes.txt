- Use direct-list initialization: int x { value }; for various reasons including:
  - Value Must be of type int (or whatever the data type is), or compiler will give an error (Easier to bug-fix)
    i.e. int x {4.5} will give an error, 4.5 is not an integer
  - Is the current/modern standard
  - Does not involve copying data, more effecient
  - Value initialization is of same format, i.e. x = {}; will set x to 0, thus easier to remember
    
- Can use extraction/insertion operators more than once
  - i.e. cin >> x >> y >> z; will take values seperated by spaces and put them into x, then y, then z.

- Declared variables are not initialized to any default values (unlike Java). int x; will not assing value 0 to x, x will be unassigned.

- Statements like x = 5 use the expression 5, which has the return value of 5, and side effect of assigning 5 to x.

- Main function always returns 0 implicitly (excluding error occurances obviously), so there is no need to put return 0; at the end.

- Can place a function below main() so long as you use forward declaration. For the function int add(int x, int y) {...}, just declare it before
  main as int add(int, int); so that main can call the actual function below it. No parameter names are required in the declaration, just types.
  However, naming them anyway is best practice. Use of forward declarations:
  - Circular-referencing functions. If two functions call each other, it is impossible to bring both of them behind the other, given the
    restrictions of spacetime.
  - Functions of other files. One cannot reorder the functions behind main when they exist in seperate files.
  - To help better organize code. If one wants to group functions, or sort them in a specific manner, forward declaration may be used.

- Dont use 'using namespace', specifically declare what namespace you mean at execution (i.e. std::cout)

- Macros can be used with the preprocessor. #define CAT DOG will replace all instances of CAT with DOG. It is unsafe, and reccomended against.

- Macros CAN however be safely used for things shown in https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/

- Header files (example.h) can be used to insert many common lines of code or forward declarations into the start of a .cpp file with the
  #include preprocessor directive. As for forward declarations, write them just the same as you would in the .cpp file. An example of this
  and multi-file organization in general can be found in /MultiFile. The files within can be compiled and linked by typing either
  "g++ fileOne.cpp fileTwo.cpp -0 MultiFile.<exe/out>" or "g++ *.cpp -o MultiFile.<exe/out>. The former only compiles and links
  listed files, while the latter compiles and links all .cpp files in the directory. Both outputs will be named MultiFile.<exe/out>

- Header files should also be included in their paired .cpp files, to stop simple errors from occuring. In MultiFile, this means it should
not only be included in fileOne.cpp, but also fileTwo.cpp.

- Using #include <x> will tell the preprocessor to check the include directories for a file we did not write. Using "x" will check\
  right next to the .cpp/.h files for a file we DID write.

- Header sorting should be as such:
  - Paired header (in add.cpp, #include "add.h")
  - Other headers of the same project (in x.cpp, #include "y.h")
  - 3rd party headers (in x.cpp, #include <boost/tuple/tuple.hpp>)
  - Standard library headers: (in x.cpp, #include <iostream>)

- Header File Best Practices:
  - Always include header guards
  - Do not define variables/functions (for now)
  - Paried .cpp and .h files should be named the same i.e. x.cpp and x.h
  - Do not include .cpp files

- Header guards help to stop duplicate declaration and initialization of functions and/or varaibles etc. They are simple to implement, just add
  a #define at the start of header files with a unique name. The name, by standard convention, is the name of the header file in all uppercase
  with underscores between words, and an H at the end. i.e. for a file named headerFile.h, use the definition #define HEADER_FILE_H. For the guard itself,
  use the following (for a file named headerFile.h):
    #ifndef HEADER_FILE_H
    #define HEADER_FILE_H
    // The header file itself, such as forward declarations, other includes, etc.
    #endif
  The code between #ifndef and #endif will only run if HEADER_FILE_H has not yet been defined. HEADER_FILE_H will be defined inside. This makes sure that
  the ODR (One Definition Rule) is not left unfollowed, and certain compile/runtime errors are not made. "#pragma once" also works in place of a traditional
  header guard in modern compilers, and is what most use (other than the old-heads at Google):
    #pragma once
    // The header file itself, such as forward declarations, other includes, etc.

- One can debug programs by adding the debugging lines of code, whatever they may be, and then only passing them through the preprocessor if a certain term is
  defined. For example, if one wants to only print out a line of code Line(); when debugging, one can place #ifdef ENABLE_DEBUG before, and #endif after. Then,
  these lines will only be passed through and compiled when the uncommented line of code #define ENABLE_DEBUG is present at the top of the file. This allows the
  inclusion and exclusion of certain lines of code, in this case debugging code, to only be compiled when that first line of code, #define ENABLE_DEBUG is present.
  Example (std::cerr... will only be compiled if #define ENABLE_DEBUG is present and NOT commented out): 

    #define ENABLE_DEBUG // comment out to disable debugging

    int getUserInput() {
      #ifdef ENABLE_DEBUG
      std::cerr << "getUserInput() called\n";
      #endif

      std::cout << "Enter a number: ";
      int x{};
      std::cin >> x;
      return x;
    }

 - Using a logger is also a possibility, like using <plog>. After initialization in main() via "plog::init(plog::debug, "Logfile.txt");" It will document any output by
   way of using "PLOGD << <output-string>;, i.e. "PLOGD << "Function Called";" NOTE: PLOG IS NOT INSTALLED BY DEFAULT, MUST BE DOWNLOADED FROM WEBSITE AND PLACED
   WITHIN INCLUDE FOLDERS! IT IS ALSO NOT THE ONLY LOGGER THAT EXISTS!

 - Using an integrated debugger is also an option, like the one in VS Code. I skipped many chapters on integrated debuggers, go back to 3.xx to reread later
   if it becomes pertinent.

 - Refactoring is the act of changing the code of a program without changing its behavior

 - Numbers are signed by default (use the first bit to define positive/negative), but can be unsigned by using the keyword i.e. unsigned int x {5};

 - The standard library allows fixed-width integers (Must "#include <cstdint>" All have "std::" prefix):
      int8_t  = 1 byte signed    = -128 -> 127
      uint8_t = 1 byte unsigned  = 0 -> 255

      int16_t  = 2 byte signed   = -32,768 -> 32,767
      uint16_t = 2 byte unsigned = 0 -> 65,535

      int32_t  = 4 byte signed   = -2,147,483,648 -> 2,147,483,647
      uint32_t = 4 byte unsigned = 0 -> 4,294,967,295

      int64_t  = 8 byte signed   = -9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807
      uint64_t = 8 byte unsigned = 0 -> 18,446,744,073,709,551,615

- Append 'f' to a number to ensure it is of float type instead of the implied double i.e. "5.0" is a double, "5.0f" is a float.

- Use "#include <iomanip>" and "std::cout << std::setprecision(int);" where int is the digits of precision for all future instances of "std::cout << <content>".
  Using more precision than is allowed by a data type will result in strange digits after the actual precision ends.

- Booleans will be printed by default as 1's and 0's, but the following command "std::cout << std::boolalpha;" will ensure all printing that occurs
  after will be printed as true's and false's. "std::cout << std::noboolalpha;" can be inversely used to revert back to 1's and 0's.

- When entering a boolean value by way of "std::cin >> <boolean>;", it must be entered as 0's or 1's, any other value (inluding words like true or false)
  will default to false (or 0). This can be changed by the statement: "std::cin >> std::boolalpha;", which will allow (case-sensitive) "true" or "false" as input.
  However, it will NO LONGER accept 0's or 1's as input.

- If the program expects a boolean (i.e. if (<boolean>) doThis();), an integer can be entered instead, where all non-zero values will be true, and 0 will be false.

- Explicit static casting can be done as such: "static_cast<type>(expression)" i.e. "static_cast<int>(5.5)" will cast the double "5.5" to an integer "5".

- Defining a constant variable goes as such: "const int {50};". The const should always go to the left of the type by convention. Varaibles that won't be changed
  should, where possible, be set as constant. This removes the potential for error in regards to the variable, lets the compiler optimize the code now that it knows
  the variable won't change, and reduces the complexity of a program.

- Defining a constant variable can also be done with "constexpr". This will generate a compile-time error if it is not actually constant, as well as whatever
  it is being defined as being constant itself. Whenever you can use "constexpr" over "const", do. For some cases however, "const" is the only/better choice.

- Literals are values inserted directly into code, without names. In the following definition "int x {5}", x is NOT a literal, as it is a variable. The '5' is
  is assigned to IS a literal, as it is an unnamed value. X has the name x, so it is not literal.

- One may have the following issue: "float x { 1.6 };" gives an error, as "1.6" is seen as a literal of type double. One can either change x from type
  float to type double, ergo "double x { 1.6 };", or change the input to a float, "float x { 1.6f };".

- Writing in scientific notation is allowed by way of using exponents. Writing 1,000,000 can also be done as 1e+6 or 1e6. 0.000001 can also be written as 1e-6.

- Other bases can be used. Writing in octal can be done by writing a zero before the octal i.e. 012 will be equal to 10. Writing in hexadecimal can be done
  with the prefix "0x" instead of '0'. i.e. 0xFFF is equal to 4095 decimal. Binary numbers can be written by the prefix "0b". i.e. 0b1111 = 15. (Only after C++14)

- Using C-style strings is dangerous, and may sometimes produce undefined behavior. Using "std::string" of "#include <string>" is prefered in cases where the string
  itelf is not literal. It allows string lengths to be changed, new values to be copied over, and is safer in general. However, things change when asking for input.
  "std::cin" will break operation on whitespace, potentially breaking a program. In this case, "std::getline()" is preferable. There are arguments that must be
  passed however. If one is trying to pass the input to a "std::string"-style string with variable name "name", write the following:
  std::getline(std::cin >> std::ws, name). This passes the input as the first, and the variable to copy data to as the second. This will take the whole line, and
  work as expected, just like before with the C-style string. The first argument technically only needs the "std::cin", but one may add the ">> std::ws" to
  specify that leading whitespace should be removed. i.e. "    x" -> "x", but "x   " does not change (whitespace is not leading).

- Add an 's' after a string literal to change it to a std::string literal. i.e. <"Hello"> is a C-Style literal, <"Hello"s> is an std::string style literal.

- One can use std::string_view to create a read-only version of a string literal.

- User defined namespaces can be used to reduce collisions of functions and variables. Done as:
    namespace NamespaceName {
      int variableOne {valueOne};
      void doSomething(int x, int y) {
        // something to do
      }
    }
  Namespaces should have every first letter be capitalized i.e. "Namespace" instead of "namespace"

- Functions and variables in namespaces must be called with either a scope resolution operator i.e. for a function named "doSomething()" in namespace "Example" one
  would call "doSomething()" by using "Example::doSomething()". If it is being called from within the same namespace, the operator is not required. But if the callee
  is in the global namespace and one tries calling it from within a namespace, the global scope can be ensured by using the scope resolution operator without a prefix,
  i.e. global function "doSomething()" can be called from namespace "Example" using the statement "::doSomething()". Without a namespace specified, it means the global
  scope.

- Forward declarations in header files also need to be in the same namespace as their corrosponding definition. i.e. for function "ExampleNamespace::doSomething()"
  declared in "foo.cpp", if one wants to call it from "bar.cpp" with a header file, the namespace "ExampleNamespace" has to be used in the header file. Find an actual
  example in Learning-Cpp/NamespaceHeader.

- The same namespace can be declared across multiple files, and all within will be considered of the same namespace.

- Namespaces can also be declared within other namespaces. i.e. for a parent namespace "Foo", child namespace "Bar", and function in namespace "Bar" named
  "doSomething()", in the global namespace or a completley seperate namespace, the function would be called as "Foo::Bar::doSomething()".

- Namespace aliases can be used to shorten the calling of certain namespaces. i.e. for the same example as before, using "namespace FoobarShortened = Foo::Bar;". from
  then on, "Foo:Bar::doSomething()" can be called as "FoobarShortened::doSomething()". Obviously, this actually lengthens the scope resolution, but if we name it
  something else, it would be more concise.

- "std::swap" can be used with "#include <utility>". If one wants to swap variables 'x' and 'y', do: "std::swap(x, y);".

- The "static" keyword can be used to make variables and functions only link within the file it is in, no other files can use it. Constexpr variables are static by default,
  but can be made usable with other files by the "extern" keyword. Integers without the "constexpr" are external by default, and can be made static. Static variables and
  functions use internal linkage, and extern(al) variables/functions use external linkage.

- The "inline" keyword can be used when defining variables or functions in header files. This keyword will allow multiple definitions of the same variable/function being
  included and duplicated into multiple .cpp files, so long as they are all identical. The compiler/linker will also remove duplicates at compile time.

- Find examples of declaring/defining/initializing variables and functions in header files within Learning-Cpp/HeaderConstants

- The many static keyword definitions:
  - Static Duration: Variables that are created on program start, and destroyed on program exit. For example, global variables have a static duration.
  - Global variables with a static prefix are made internally linked.
  - Local variables with the static prefix will be created at the start of the program, and destroyed at program exit. This is just like how un-prefixed global variables
    work. However, these local variables will only be initialized once, so as to avoid errors. An example can be found at "Learning-Cpp/Assorted/staticVariables.cpp".
    These static-local variables can be used to generate a new copy of an integer/other type every function call, while keeping track of what increment the variable
    should be.