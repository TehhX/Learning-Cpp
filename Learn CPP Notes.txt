Examples for all concepts and points either in "./Assorted/", or a seperate folder if they have multiple files. >= C++17 assumed.
Not everything stated is true 100% of the time, this is from the general experience of someone new to the language learning from
"learncpp.com". No consistency is guaranteed :^)

-------------------------------------------------------------------------------------------------------------------------------------------------

- Use direct-list initialization: int x { value }; for various reasons including:
  - Value Must be of the given type, or compiler will give an error i.e. int x {4.5} will give an error, 4.5 is not an integer
  - Does not involve copying data, more effecient
  - Value initialization is of same format, i.e. x = {}; will set x to 0, thus easier to remember

- Can use extraction/insertion operators more than once, i.e. cin >> x >> y >> z; will take values seperated by whitespace and put them
  into x, then y, then z.

- Declared variables are not initialized to any default values (unlike Java). int x; will not assing value 0 to x, x will be unassigned.

- Statements like x = 5 use the expression 5, which has the return value of 5, and side effect of assigning 5 to x.

- Main function always returns 0 implicitly (excluding error occurances obviously), so there is no need to put return 0; at the end.

- Forward declarartions can be used for many things, by simply writing "T func(T, {etc.});" without the definition.
  - Circular-referencing functions. If two functions call each other, it is impossible to bring both of them behind the other, given the
    restrictions of spacetime.
  - Functions of other files. One cannot reorder the functions behind main when they exist in seperate files.
  - To help better organize code. If one wants to group functions, or sort them in a specific manner, forward declaration may be used.

- Dont use 'using namespace', specifically declare what namespace you mean line-by-line i.e. std::cout

- Macros can be used with the preprocessor. #define CAT DOG will replace all instances of CAT with DOG. It is unsafe, and reccomended agains

- Header files (example.h) can be used to insert many common pieces of code into multiple .cpp files such as:
  - Forward declarations
  - Common standard libraries
  - Templates
  - Global variable and function definitions

- Header files should also be included in their paired .cpp files, to stop simple errors from occuring. In MultiFile, this means it should
  not only be included in fileOne.cpp, but also fileTwo.cpp. If function types from forward declaration to definition are mismatched, the
  compiler will only complain if this practice is followed.

- Header sorting should be as such:
  - Paired header (in add.cpp, #include "add.h")
  - Other headers of the same project (in x.cpp, #include "y.h")
  - 3rd party headers (in x.cpp, #include <boost/tuple/tuple.hpp>)
  - Standard library headers: (in x.cpp, #include <iostream>)

- Header File Best Practices:
  - Always #pragma once
  - Paried .cpp and .h files should be named the same i.e. x.cpp and x.h
  - Do not include .cpp files

- Defining certain macros can make certain lines of code not compile with #ifdef for various purposes. Find an example
  in "./Assorted/debugDefinition.cpp".

- Refactoring is the act of changing the code of a program without changing its behavior

- Numbers are signed by default (use the first bit to define positive/negative), but can be unsigned by using the keyword
  i.e. unsigned int x {5};

- The standard library allows fixed-width integers (Must "#include <cstdint>" All have "std::" prefix) Value ranges:
    - int8_t  = 1 byte signed    =                       -128 -> 127
    - uint8_t = 1 byte unsigned  =                          0 -> 255

    - int16_t  = 2 byte signed   =                    -32,768 -> 32,767
    - uint16_t = 2 byte unsigned =                          0 -> 65,535

    - int32_t  = 4 byte signed   =             -2,147,483,648 -> 2,147,483,647
    - uint32_t = 4 byte unsigned =                          0 -> 4,294,967,295

    - int64_t  = 8 byte signed   = -9,223,372,036,854,775,808 ->  9,223,372,036,854,775,807
    - uint64_t = 8 byte unsigned =                          0 -> 18,446,744,073,709,551,615

- Append 'f' to a number to ensure it is of float type instead of the implied double i.e. "5.0" is a double, "5.0f" is a float.

- Use "#include <iomanip>" and "std::cout << std::setprecision(int);" where int is the digits of precision for all future
  instances of "std::cout << {...}". Using more precision than is allowed by a data type will result in undefined digits
  after the actual precision ends. To have precision only affect post decimal digits, use "std::cout << std::fixed;" before
  "setprecision".

- Booleans will be printed by default as 1's and 0's, but the following command "std::cout << std::boolalpha;" will ensure all printing that
  occurs after will be printed as true's and false's. "std::cout << std::noboolalpha;" can be inversely used to revert back to 1's and 0's.

- When entering a boolean value by way of "std::cin >> bool;", it must be entered as 0's or 1's, any other value (inluding words like
  true or false) will default to false (or 0). This can be changed by the statement: "std::cin >> std::boolalpha;", which will allow
  (case-sensitive) "true" or "false" as input. However, it will NO LONGER accept 0's or 1's as input.

- If the program expects a boolean (i.e. if (bool) doThis();), an integer can be entered instead, where all non-zero values will be
  true, and 0 will be false.

- Explicit static casting can be done as such: "static_cast<T>(expression)" i.e. "static_cast<int>(5.5)" will cast the double "5.5"
  to an integer "5".

- Defining a constant variable goes as such: "const int {50};". The const should always go to the left of the type by convention.
  Varaibles that won't be changed should be made constant. This removes the potential for error in regards to the variable, lets the
  compiler optimize the code now that it knows the variable won't change, and reduces the complexity of a program.

- Defining a constant variable can also be done with "constexpr". This will generate a compile-time error if it is not actually constant,
  as well as whatever it is being defined as being constant itself. Whenever you can use "constexpr" over "const", do. For some cases
  however, "const" is the only/better choice.

- Literals are values inserted directly into code, without names. In the following definition "int x {5}", x is NOT a literal, as it is a
  variable. The '5' is is assigned to IS a literal, as it is an unnamed value. X has the name x, so it is not literal.

- One may have the following issue: "float x { 1.6 };" gives an error, as "1.6" is seen as a literal of type double. One can either change
  x from type float to type double, ergo "double x { 1.6 };", or change the input to a float, "float x { 1.6f };".

- Writing in scientific notation is allowed by way of using exponents. Writing 1,000,000 can also be done as 1e+6 or 1e6. 0.000001 can
  also be written as 1e-6.

- Other bases can be used. Writing in octal can be done by writing a zero before the octal i.e. 012 will be equal to 10. Writing in
  hexadecimal can be done with the prefix "0x" instead of '0'. i.e. 0xFFF is equal to 4095 decimal. Binary numbers can be written by the
  prefix "0b". i.e. 0b1111 = 15.

- Using C-style strings is dangerous, and may sometimes produce undefined behavior. Using "std::string" of "#include <string>" is prefered
  in cases where the string itelf is not literal. It allows string lengths to be changed, new values to be copied over, and is safer in
  general. However, things change when asking for input. "std::cin" will break operation on whitespace, potentially breaking a program.
  In this case, "std::getline()" is preferable. There are arguments that must be passed however. If one is trying to pass the input to a
  "std::string"-style string with variable name "name", write "std::getline(std::cin >> std::ws, name)". This passes the input as the first,
  and the variable to copy data to as the second. This will take the whole line, and work as expected, just like before with the C-style
  string. The first argument technically only needs the "std::cin", but one may add the ">> std::ws" to specify that leading whitespace
  should be removed. i.e. "    x" -> "x", but "x   " does not change (whitespace is not leading).

- Add an 's' after a string literal to change it to a std::string literal. i.e. <"Hello"> is a C-Style literal, <"Hello"s> is an std::string
  style literal.

- One can use std::string_view to create a read-only version of a string literal.

- User defined namespaces can be used to reduce collisions of functions and variables. Done as:
    namespace NamespaceName {
      int variableOne {valueOne};
      void doSomething(int x, int y) {
        // something to do
      }
    }
  Namespaces should have every first letter be capitalized i.e. "Namespace" instead of "namespace"

- Functions and variables in namespaces must be called with either a scope resolution operator i.e. for a function named "doSomething()"
  in namespace "Example" one would call "doSomething()" by using "Example::doSomething()". If it is being called from within the same
  namespace, the operator is not required. But if the callee is in the global namespace and one tries calling it from within a namespace,
  the global scope can be ensured by using the scope resolution operator without a prefix, i.e. global function "doSomething()" can be called
  from namespace "Example" using the statement "::doSomething()". Without a namespace specified, it means the global scope.

- Forward declarations in header files also need to be in the same namespace as their corrosponding definition. i.e. for function
  "ExampleNamespace::doSomething()" declared in "foo.cpp", if one wants to call it from "bar.cpp" with a header file, the namespace
  "ExampleNamespace" has to be used in the header file. Find an actual example in Learning-Cpp/NamespaceHeader.

- The same namespace can be declared across multiple files, and all within will be considered of the same namespace.

- Namespaces can also be declared within other namespaces. i.e. for a parent namespace "Foo", child namespace "Bar", and function in namespace
  "Bar" named "doSomething()", in the global namespace or a completley seperate namespace, the function would be called as
  "Foo::Bar::doSomething()".

- Namespace aliases can be used to shorten the calling of certain namespaces. i.e. for the same example as before, using
  "namespace FoobarShortened = Foo::Bar;". from then on, "Foo:Bar::doSomething()" can be called as "FoobarShortened::doSomething()". Obviously,
  this actually lengthens the scope resolution, but if we name it something shorter it can be made more concise.

- "std::swap" can be used with "#include <utility>". If one wants to swap variables 'x' and 'y', do: "std::swap(x, y);".

- The "static" keyword can be used to make variables and functions only link within the file it is in, no other files can use it. Constexpr
  variables are static by default, but can be made usable with other files by the "extern" keyword. Integers without the "constexpr" are
  external by default, and can be made static. Static variables and functions use internal linkage, and extern(al) variables/functions use
  external linkage.

- The "inline" keyword can be used when defining variables or functions in header files. This keyword will allow multiple definitions of the same
  variable/function being included and duplicated into multiple .cpp files, so long as they are all identical. The compiler/linker will also
  remove duplicates at compile time.

- Find examples of declaring/defining/initializing variables and functions in header files within Learning-Cpp/HeaderConstants

- The many static keyword definitions:
  - Static Duration: Variables that are created on program start, and destroyed on program exit. For example, global variables have a static
    duration.
  - Global variables with a static prefix are made internally linked.
  - Local variables with the static prefix will be created at the start of the program, and destroyed at program exit. This is just like how
    un-prefixed global variables work. However, these local variables will only be initialized once, so as to avoid errors. An example can be
    found at "Learning-Cpp/Assorted/staticVariables.cpp". These static-local variables can be used to generate a new copy of an integer/other
    type every function call, while keeping track of what increment the variable should be.

- Constexpr if statements can be used if constexpr variables defined before are a part of the condition, see "./Assorted/constexprIf.cpp".

- Don't indent switch statement cases i.e.
    switch (value) {
    case x:
      doX();
      return;
    case y:
      doY():
      [[fallthrough]];
    default:
      doDefault();
    }

- The fallthrough statement can be used to indicate intentional fallthrough. Place "[[fallthrough]]" at the end of a case. Example in last
  point. It doesn't do anything other than show that fallthrough is intentional, and potentially disable some compuler warnings, as the
  code will execute just the same without it.

- The "goto" keyword can jump to a particular part of the program by a label. An example can be found in "./Assorted/gotoBackwards.cpp".
  The goto label can also jump forwards, found in "./Assorted/gotoForwards.cpp". Goto statements do not need to be declared by the time they're
  called, like variables and functions do. Goto statements are generally unused, but have some niche uses.

- Modulus usage example in "./Assorted/fizzBuzz.cpp".

- The "continue" keyword can be used to break out of the current iteration of a loop statement, but continue to loop through it starting at
  the next index, or beginning. This keyword is used similarly to the "break" keyword, but doesn't completely exit the loop.

- A running program can be called before main() ends by using "#include <cstdlib> {...} std::exit();" Also, "std::atexit(func);" will
  call "func", and then exit the program as "std::exit();" does after "func" completes.

- Random numbers in C++ can be generated using multiple functions from "#include <random>". First, a random number for the seed needs to be
  picked or otherwidse generated. A single random number can be taken from "std::random_device", and put into the Mersenne Twister algorithm.
  It should be input multiple times (8 minimum) to help seed the MT algorithm. A uniform integer distributor can be used to distribute random
  numbers taken from this algorithm, and distribute the numbers between a minimum and maximum. Multiple different distributors can be used with
  the same RNG. An example of an RNG can be found in "./Assorted/randomNumber.cpp".

- Assertive statements with "#include <cassert>" can detect problems and end the program. Regular assertions i.e. "assert(<true_thing>);" can
  become more descriptive, i.e. "assert(true && std::string);" will print to the console what was false, and the string passed to it. This
  helps with error logging. However, asserts should not be used in production code, only to help with debugging. 

- Static assertive statements can be used to evaluate code at compile time, without needing an "#include" header.
  "static_assert(true, string);". It requires a constexpr as the "true" however.

- There are multiple different explicit ways to cast a variable or literal. These include C and C++ style casts. C++ style casts have the
  benefit of being named, and being more specific. C style casts may also perform differently than expected. Check the following table:
    - C-Style Casts:
      - "(T) x"
      - "T(x)"
    - C++-Style Casts (In order of what the C-style cast tries to do):
      - "const_cast<T>(x)"
      - "static_cast<T>(x)"
      - "reinterpret_cast<T>(x)"
      - "dynamic_cast<T>(x)" (C-Style cast does not try to dynamic_cast at any point AFAIK)
      
- Implicit type conversion is done by the compiler without instruction from the programmer.

- Aliases can be created with the "using" keyword i.e. "using <new_key> = <old_key>;". They can also be included with a header file, as they
  will be declared in the global namespace of all ".cpp" files that include the header file. This is useful for shortening long type names.

- Functions with parameters may have default arguments for any or all of the parameters. The argument MUST be defined with the copy operator
  "=", direct-list initialization and others won't work. See "./Assorted/defaultArguments.cpp".

- Templates are a functionality in C++ for creating reusable functions that can take multiple different types for a single parameter.
  - Certain input types can be deleted with the "= delete;" suffix, replacing all type placeholders with whatever should not be allowed.
  - Local static keywords will not keep their value between different type implementations of the template. This is because the compiler makes
    different functions for the template when they are required, and they initialize different variables.
  - Templates can have multiple wildcard types. When returning a value from multiple types, the auto keyword can be useful. It will deduce the
    correct type, and return it as such.
  - Template definitions in header files don't need the inline keyword as regular functions do.

- When compiling multiple files, start with the .cpp file that has the main function in it, or else the compiler will throw an error.

- Creating a constexpr variable requires the initializing variable to be a constant or literal itself. That means that functions aren't allowed
  as the input. This is where constexpr functions come into play. Find an example of its usage in "./Assorted/constexprFunc.cpp".

- LValue references can be used to reference an existing variable and make somewhat of an alias of it. Reference variables MUST be initialized
  on declaration, it cannot be left null. Find an example in "./Assorted/lvalueRef.cpp".

- LValue references cannot initialize and reference to:
  - Const vars, when the reference itself is not also const
  - RValues, like Literals

- LValues cannot be changed to reference another value or variable. Example in same file as before.

- References and the variables they're referencing have independent life times. References becoming deleted before their accompanying originals
  can occur in certain circumstances, but the original is not impacted. However, the original becoming deleted before the reference does impact
  the reference, leading to undefined behavior. This is called a dangling reference.

- References are not objects, and will be replaced by their referent at compile time where possible.

- References can be made constant when their originals are mutable, and the program will still work as expected. However, references cannot
  edit the original, so this makes things a bit safer. Editing the original will change the reference, even if the reference is const.

- Constexpr references need either a global variable, or a local static variable.

- Passing by value and passing by reference are two different things. They both refer to arguments inserted into function parameters, however
  what they pass are different. When passing by value, the object argument is copied onto the parameter in the function, and the function runs.
  This is fine for primitive types, but for classes and more expensive types, passing by reference is cheaper to run. Find an example in
  "./Assorted/passByRef.cpp".

- Passing by value also differs to reference in terms of what can be edited in the function. Passing by value allows one to edit a copy
  of the passed value or class object etc, leaving the original intact. While this is desirable a lot of the time, passing by reference
  alows the original to be directly edited, which is just as useful. Same place for example.

- When passing a const by reference, the parameter must also be const. Same place again for example.

- An object is cheap to copy if it uses the size of <= 2 memory addresses.

- "std::string_view" is cheaper to copy and easier to work with than "const std::string&" in parameters.

- The address of operator, "&", can be placed before a variable to get its address in memory. The dereference operator, "*", can be
  placed before a memory address to get the value at the address. Find an example of both (with undefined behavior) in
  "./Assorted/addressOperators.cpp". When the variable that the "address of" operator is referencing has more than one byte, it
  gives the address of the first byte.

- Pointers can be used to point to the address of an object in memory. Pointers, like other variables, must be initialized to a value,
  or else they will give garbage out. When a pointer is initialized with an empty direct-list initialization, it will be a null-pointer.
  Find an example in "./Assorted/pointers.cpp".

- Pointers that point to an object that no longer exists are dangling pointers, very similar to dangling references.

- Null-pointers, mentioned previously, are pointers that don't point to any value. Attempting to print the value will lead to undefined
  behavior, g++ gives a segfault error. Example in "./Assorted/nullPointers.cpp".

- Pointers that become dangling should always reach the end of their lifetime, or be set to nullptr. Dangling pointers themselves should
  exist for the shortest amount of time possible in any case. This allows one to assume any "!= nullptr" pointer is valid and not dangling,
  and that any "== nullptr" pointer is null (obviously).

- Older code might use outdated ways of assigning a pointer to null i.e. "T* x {0}", "T* x {NULL};" instead of the modern "T* x {nullptr};"

- Pointers of a non const type cannot point at a const type. The type of a pointer must be made const to point at a const type. This means
  that the pointer cannot modify the const variable. Pointers of a const type i.e. "const int" can point at a non const variable i.e "int".
  The pointer, however, still cannot modify the variable it points at, whether the variable is const or not. Example in
  "./Assorted/constPointers.cpp".

- Pointers themselves, not the type they point at, can also be const. This changes it so that the pointer cannot be reseated. However, a
  const pointer can still be dereferenced to change the value at the address. This means that the only thing that is different about
  const pointers is the fact that they cannot change what they are pointing at.

- Note the difference between a pointer to a constant type and a constant pointer to a type, both in how they work and how their syntax
  differ from one another.

- Another way to pass through a parameter is by address (in addition to value and reference from before). Example in 
  "./Assorted/passByAddress.cpp"

- Prefer pass by reference to pass by address when possible. Avoids null-pointer errors. If using pass by address, place "assert(ptr)"
  at the start of the function to make sure the program says when a null-pointer is accidentally passed. There are scenarios when a
  null pointer is acceptable/wanted when assert shouldn't be used.

- A function with a pointer default argument can have that default argument as nullptr. Then, within that function, certain things can
  be done if the pointer is null. Function overloading is often better, though.

- Passing an address creates a copy of the pointer, meaning that the original pointer passed as the argument cannot be changed within
  the function, such as changing what it points at (but what it points at CAN be changed). To change the original pointer from within
  a function, the address must be passed by reference. Example at "./Assorted/passAddressByRef.cpp".

- Returning by reference is often less expensive than returning by value. It just requires the return reference to outlive the
  function. Placing const before the return type does nothing special at runtime, but helps to prevent bad code. Example in
  "./Assorted/returnBy.cpp".

- If a parameter is passed by reference, it can safely be returned as a reference because its lifetime will exist outside of the
  function's scope.

- Functions that return a reference can be used as the LHS of an operation. Example in "Assorted/outParameters.cpp".
  Out parameters can also be used to modify variables that exist outside of the scope of a function.

- Prefer returning by reference over by pointer, unless it is important to have returning nullptr as a possibility.

- Out parameters should be avoided unless they truely are the best option for a given issue.

- Optional objects can be returned instead of their regular counterparts if an error is possible to occur inside the function.
  Example in "Assorted/optionals.cpp".

- Prefer passing by const T& instead of T& when possible, as more things are possible with constant reference values as parameters.

- User defined types like enumerations and classes can be used for compound data types that are not defined by Cpp.
  Example in "Assorted/basicStruct.cpp" and "Assorted/basicEnumerator.cpp".

- Place enumerators inside their own namespaces. Example in "Assorted/namespacedEnumerator.cpp"

- Enumerators can have assigned values inside of them. Any unassigned enumerations inside of an enum that also contains assigned
  enumerations will always continue from the last enumeration. More than one enumeration can be assigned the same number, even if
  it is just the same number as an unassigned enumeration. Examples in "Assorted/assignedEnumerator.cpp". 

- Enumerators have a base type, usually of type "int". However, they can be speicified at the enum header. Example in
  "Assorted/enumBaseTypes.cpp"

- Maybe prefer unnamed enums inside namespaces if the namespace only contains the enum itself. Example in "Assorted/simpleEnumScopes.cpp"

- Default (first/0) enum values should be the value seen as the defualt, or as close to what the default is as can be.

- Enums should always have a specified base type, even if it is just "int". Example with reason why in "Assorted/enumTypeConversions.cpp"

- Enums can be converted to and from strings. Example in "Assorted/enumStringInput.cpp" and "Assorted/enumStringOutput.cpp".

- 