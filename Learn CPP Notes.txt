Examples for all concepts and points either in "./Assorted/", or a seperate folder if they have multiple files. >= C++17 assumed.

-------------------------------------------------------------------------------------------------------------------------------------------------

- Use direct-list initialization: int x { value }; for various reasons including:
  - Value Must be of the given type, or compiler will give an error i.e. int x {4.5} will give an error, 4.5 is not an integer
  - Does not involve copying data, more effecient
  - Value initialization is of same format, i.e. x = {}; will set x to 0, thus easier to remember

- Can use extraction/insertion operators more than once, i.e. cin >> x >> y >> z; will take values seperated by whitespace and put them
  into x, then y, then z.

- Declared variables are not initialized to any default values (unlike Java). int x; will not assing value 0 to x, x will be unassigned.

- Statements like x = 5 use the expression 5, which has the return value of 5, and side effect of assigning 5 to x.

- Main function always returns 0 implicitly (excluding error occurances obviously), so there is no need to put return 0; at the end.

- Forward declarartions can be used for many things, by simply writing "<type> func(<type>, {etc.});" without the definition.
  - Circular-referencing functions. If two functions call each other, it is impossible to bring both of them behind the other, given the
    restrictions of spacetime.
  - Functions of other files. One cannot reorder the functions behind main when they exist in seperate files.
  - To help better organize code. If one wants to group functions, or sort them in a specific manner, forward declaration may be used.

- Dont use 'using namespace', specifically declare what namespace you mean line-by-line i.e. std::cout

- Macros can be used with the preprocessor. #define CAT DOG will replace all instances of CAT with DOG. It is unsafe, and reccomended agains

- Header files (example.h) can be used to insert many common pieces of code into multiple .cpp files such as:
  - Forward declarations
  - Common standard libraries
  - Templates
  - Global variable and function definitions

- Header files should also be included in their paired .cpp files, to stop simple errors from occuring. In MultiFile, this means it should
  not only be included in fileOne.cpp, but also fileTwo.cpp. If function types from forward declaration to definition are mismatched, the
  compiler will only complain if this practice is followed.

- Header sorting should be as such:
  - Paired header (in add.cpp, #include "add.h")
  - Other headers of the same project (in x.cpp, #include "y.h")
  - 3rd party headers (in x.cpp, #include <boost/tuple/tuple.hpp>)
  - Standard library headers: (in x.cpp, #include <iostream>)

- Header File Best Practices:
  - Always #pragma once
  - Paried .cpp and .h files should be named the same i.e. x.cpp and x.h
  - Do not include .cpp files

- Defining certain macros can make certain lines of code not compile with #ifdef for various purposes. Find an example
  in "./Assorted/debugDefinition.cpp".

- Refactoring is the act of changing the code of a program without changing its behavior

- Numbers are signed by default (use the first bit to define positive/negative), but can be unsigned by using the keyword
  i.e. unsigned int x {5};

- The standard library allows fixed-width integers (Must "#include <cstdint>" All have "std::" prefix) Value ranges:
    - int8_t  = 1 byte signed    =                       -128 -> 127
    - uint8_t = 1 byte unsigned  =                          0 -> 255

    - int16_t  = 2 byte signed   =                    -32,768 -> 32,767
    - uint16_t = 2 byte unsigned =                          0 -> 65,535

    - int32_t  = 4 byte signed   =             -2,147,483,648 -> 2,147,483,647
    - uint32_t = 4 byte unsigned =                          0 -> 4,294,967,295

    - int64_t  = 8 byte signed   = -9,223,372,036,854,775,808 ->  9,223,372,036,854,775,807
    - uint64_t = 8 byte unsigned =                          0 -> 18,446,744,073,709,551,615

- Append 'f' to a number to ensure it is of float type instead of the implied double i.e. "5.0" is a double, "5.0f" is a float.

- Use "#include <iomanip>" and "std::cout << std::setprecision(int);" where int is the digits of precision for all future
  instances of "std::cout << <content>". Using more precision than is allowed by a data type will result in undefined digits
  after the actual precision ends.

- Booleans will be printed by default as 1's and 0's, but the following command "std::cout << std::boolalpha;" will ensure all printing that
  occurs after will be printed as true's and false's. "std::cout << std::noboolalpha;" can be inversely used to revert back to 1's and 0's.

- When entering a boolean value by way of "std::cin >> <boolean>;", it must be entered as 0's or 1's, any other value (inluding words like
  true or false) will default to false (or 0). This can be changed by the statement: "std::cin >> std::boolalpha;", which will allow
  (case-sensitive) "true" or "false" as input. However, it will NO LONGER accept 0's or 1's as input.

- If the program expects a boolean (i.e. if (<boolean>) doThis();), an integer can be entered instead, where all non-zero values will be
  true, and 0 will be false.

- Explicit static casting can be done as such: "static_cast<type>(expression)" i.e. "static_cast<int>(5.5)" will cast the double "5.5"
  to an integer "5".

- Defining a constant variable goes as such: "const int {50};". The const should always go to the left of the type by convention.
  Varaibles that won't be changed should be made constant. This removes the potential for error in regards to the variable, lets the
  compiler optimize the code now that it knows the variable won't change, and reduces the complexity of a program.

- Defining a constant variable can also be done with "constexpr". This will generate a compile-time error if it is not actually constant,
  as well as whatever it is being defined as being constant itself. Whenever you can use "constexpr" over "const", do. For some cases
  however, "const" is the only/better choice.

- Literals are values inserted directly into code, without names. In the following definition "int x {5}", x is NOT a literal, as it is a
  variable. The '5' is is assigned to IS a literal, as it is an unnamed value. X has the name x, so it is not literal.

- One may have the following issue: "float x { 1.6 };" gives an error, as "1.6" is seen as a literal of type double. One can either change
  x from type float to type double, ergo "double x { 1.6 };", or change the input to a float, "float x { 1.6f };".

- Writing in scientific notation is allowed by way of using exponents. Writing 1,000,000 can also be done as 1e+6 or 1e6. 0.000001 can
  also be written as 1e-6.

- Other bases can be used. Writing in octal can be done by writing a zero before the octal i.e. 012 will be equal to 10. Writing in
  hexadecimal can be done with the prefix "0x" instead of '0'. i.e. 0xFFF is equal to 4095 decimal. Binary numbers can be written by the
  prefix "0b". i.e. 0b1111 = 15.

- Using C-style strings is dangerous, and may sometimes produce undefined behavior. Using "std::string" of "#include <string>" is prefered
  in cases where the string itelf is not literal. It allows string lengths to be changed, new values to be copied over, and is safer in
  general. However, things change when asking for input. "std::cin" will break operation on whitespace, potentially breaking a program.
  In this case, "std::getline()" is preferable. There are arguments that must be passed however. If one is trying to pass the input to a
  "std::string"-style string with variable name "name", write "std::getline(std::cin >> std::ws, name)". This passes the input as the first,
  and the variable to copy data to as the second. This will take the whole line, and work as expected, just like before with the C-style
  string. The first argument technically only needs the "std::cin", but one may add the ">> std::ws" to specify that leading whitespace
  should be removed. i.e. "    x" -> "x", but "x   " does not change (whitespace is not leading).

- Add an 's' after a string literal to change it to a std::string literal. i.e. <"Hello"> is a C-Style literal, <"Hello"s> is an std::string
  style literal.

- One can use std::string_view to create a read-only version of a string literal.

- User defined namespaces can be used to reduce collisions of functions and variables. Done as:
    namespace NamespaceName {
      int variableOne {valueOne};
      void doSomething(int x, int y) {
        // something to do
      }
    }
  Namespaces should have every first letter be capitalized i.e. "Namespace" instead of "namespace"

- Functions and variables in namespaces must be called with either a scope resolution operator i.e. for a function named "doSomething()"
  in namespace "Example" one would call "doSomething()" by using "Example::doSomething()". If it is being called from within the same
  namespace, the operator is not required. But if the callee is in the global namespace and one tries calling it from within a namespace,
  the global scope can be ensured by using the scope resolution operator without a prefix, i.e. global function "doSomething()" can be called
  from namespace "Example" using the statement "::doSomething()". Without a namespace specified, it means the global scope.

- Forward declarations in header files also need to be in the same namespace as their corrosponding definition. i.e. for function
  "ExampleNamespace::doSomething()" declared in "foo.cpp", if one wants to call it from "bar.cpp" with a header file, the namespace
  "ExampleNamespace" has to be used in the header file. Find an actual example in Learning-Cpp/NamespaceHeader.

- The same namespace can be declared across multiple files, and all within will be considered of the same namespace.

- Namespaces can also be declared within other namespaces. i.e. for a parent namespace "Foo", child namespace "Bar", and function in namespace
  "Bar" named "doSomething()", in the global namespace or a completley seperate namespace, the function would be called as
  "Foo::Bar::doSomething()".

- Namespace aliases can be used to shorten the calling of certain namespaces. i.e. for the same example as before, using
  "namespace FoobarShortened = Foo::Bar;". from then on, "Foo:Bar::doSomething()" can be called as "FoobarShortened::doSomething()". Obviously,
  this actually lengthens the scope resolution, but if we name it something shorter it can be made more concise.

- "std::swap" can be used with "#include <utility>". If one wants to swap variables 'x' and 'y', do: "std::swap(x, y);".

- The "static" keyword can be used to make variables and functions only link within the file it is in, no other files can use it. Constexpr
  variables are static by default, but can be made usable with other files by the "extern" keyword. Integers without the "constexpr" are
  external by default, and can be made static. Static variables and functions use internal linkage, and extern(al) variables/functions use
  external linkage.

- The "inline" keyword can be used when defining variables or functions in header files. This keyword will allow multiple definitions of the same
  variable/function being included and duplicated into multiple .cpp files, so long as they are all identical. The compiler/linker will also
  remove duplicates at compile time.

- Find examples of declaring/defining/initializing variables and functions in header files within Learning-Cpp/HeaderConstants

- The many static keyword definitions:
  - Static Duration: Variables that are created on program start, and destroyed on program exit. For example, global variables have a static
    duration.
  - Global variables with a static prefix are made internally linked.
  - Local variables with the static prefix will be created at the start of the program, and destroyed at program exit. This is just like how
    un-prefixed global variables work. However, these local variables will only be initialized once, so as to avoid errors. An example can be
    found at "Learning-Cpp/Assorted/staticVariables.cpp". These static-local variables can be used to generate a new copy of an integer/other
    type every function call, while keeping track of what increment the variable should be.

- Constexpr if statements can be used if constexpr variables defined before are a part of the condition, see "./Assorted/constexprIf.cpp".

- Don't indent switch statement cases i.e.
    switch (value) {
    case x:
      doX();
      return;
    case y:
      doY():
      [[fallthrough]];
    default:
      doDefault();
    }

- The fallthrough statement can be used to indicate intentional fallthrough. Place "[[fallthrough]]" at the end of a case. Example in last
  point. It doesn't do anything other than show that fallthrough is intentional, and potentially disable some compuler warnings, as the
  code will execute just the same without it.

- The "goto" keyword can jump to a particular part of the program by a label. An example can be found in "./Assorted/gotoBackwards.cpp".
  The goto label can also jump forwards, found in "./Assorted/gotoForwards.cpp". Goto statements do not need to be declared by the time they're
  called, like variables and functions do. Goto statements are generally unused, but have some niche uses.

- Modulus usage example in "./Assorted/fizzBuzz.cpp".

- The "continue" keyword can be used to break out of the current iteration of a loop statement, but continue to loop through it starting at
  the next index, or beginning. This keyword is used similarly to the "break" keyword, but doesn't completely exit the loop.

- A running program can be called before main() ends by using "#include <cstdlib> {...} std::exit();" Also, "std::atexit(<function>);" will
  call <function>, and then exit the program as "std::exit();" does after <function> completes.

- Random numbers in C++ can be generated using multiple functions from "#include <random>". First, a random number for the seed needs to be
  picked or otherwidse generated. A single random number can be taken from "std::random_device", and put into the Mersenne Twister algorithm.
  It should be input multiple times (8 minimum) to help seed the MT algorithm. A uniform integer distributor can be used to distribute random
  numbers taken from this algorithm, and distribute the numbers between a minimum and maximum. Multiple different distributors can be used with
  the same RNG. An example of an RNG can be found in "./Assorted/randomNumber.cpp".

- Assertive statements with "#include <cassert>" can detect problems and end the program. Regular assertions i.e. "assert(<true_thing>);" can
  become more descriptive, i.e. "assert(<true_thing> && <string>);" will print to the console what was false, and the string passed to it. This
  helps with error logging. However, asserts should not be used in production code, only to help with debugging. 

- Static assertive statements can be used to evaluate code at compile time, without needing an "#include" header.
  "static_assert(<true_thing>, <string_literal>);". It requires a constexpr as the <true_thing> however.

- There are multiple different explicit ways to cast a variable or literal. These include C and C++ style casts. C++ style casts have the
  benefit of being named, and being more specific. C style casts may also perform differently than expected. Check the following table:
    - C-Style Casts:
      - "(<type>) <var/literal>"
      - "<type>(<var.literal>)"
    - C++-Style Casts (In order of what the C-style cast tries to do):
      - "const_cast<<type>>(<var/literal>)"
      - "static_cast<<type>>(<var/literal>)"
      - "reinterpret_cast<<type>>(<var/literal>)"
      - "dynamic_cast<<type>>(<var/literal>)" (C-Style cast does not try to dynamic_cast at any point AFAIK)
      
- Implicit type conversion is done by the compiler without instruction from the programmer.

- Aliases can be created with the "using" keyword i.e. "using <new_key> = <old_key>;". They can also be included with a header file, as they
  will be declared in the global namespace of all ".cpp" files that include the header file. This is useful for shortening long type names.

- Functions with parameters may have default arguments for any or all of the parameters. The argument MUST be defined with the copy operator
  "=", direct-list initialization and others won't work. See "./Assorted/defaultArguments.cpp".

- Templates are a functionality in C++ for creating reusable functions that can take multiple different types for a single parameter.
  - Certain input types can be deleted with the "= delete;" suffix, replacing all type placeholders with whatever should not be allowed.
  - Local static keywords will not keep their value between different type implementations of the template. This is because the compiler makes
    different functions for the template when they are required, and they initialize different variables.
  - Templates can have multiple wildcard types. When returning a value from multiple types, the auto keyword can be useful. It will deduce the
    correct type, and return it as such.
  - Template definitions in header files don't need the inline keyword as regular functions do.

- When compiling multiple files, start with the .cpp file that has the main function in it, or else the compiler will throw an error.