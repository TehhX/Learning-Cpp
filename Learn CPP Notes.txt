- Use direct-list initialization: int x { value }; for various reasons including:
  - Value Must be of type int (or whatever the data type is), or compiler will give an error (Easier to bug-fix)
    i.e. int x {4.5} will give an error, 4.5 is not an integer
  - Is the current/modern standard
  - Does not involve copying data, more effecient
  - Value initialization is of same format, i.e. x = {}; will set x to 0, thus easier to remember
    
- Can use extraction/insertion operators more than once
  - i.e. cin >> x >> y >> z; will take values seperated by spaces and put them into x, then y, then z.

- Declared variables are not initialized to any default values (unlike Java). int x; will not assing value 0 to x, x will be unassigned.

- Statements like x = 5 use the expression 5, which has the return value of 5, and side effect of assigning 5 to x.

- Main function always returns 0 implicitly (excluding error occurances obviously), so there is no need to put return 0; at the end.

- Can place a function below main() so long as you use forward declaration. For the function int add(int x, int y) {...}, just declare it before
  main as int add(int, int); so that main can call the actual function below it. No parameter names are required in the declaration, just types.
  However, naming them anyway is best practice. Use of forward declarations:
  - Circular-referencing functions. If two functions call each other, it is impossible to bring both of them behind the other, given the
    restrictions of spacetime.

  - Functions of other files. One cannot reorder the functions behind main when they exist in seperate files.

  - To help better organize code. If one wants to group functions, or sort them in a specific manner, forward declaration may be used.

- Dont use 'using namespace', specifically declare what namespace you mean at execution (i.e. std::cout)

- Macros can be used with the preprocessor. #define CAT DOG will replace all instances of CAT with DOG. It is unsafe, and reccomended against.

- Macros CAN however be safely used for things shown in https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/

- Header files (example.h) can be used to insert many common lines of code or forward declarations into the start of a .cpp file with the
  #include preprocessor directive. As for forward declarations, write them just the same as you would in the .cpp file. An example of this
  and multi-file organization in general can be found in /MultiFile. The files within can be compiled and linked by typing either
  "g++ fileOne.cpp fileTwo.cpp -0 MultiFile.<exe/out>" or "g++ *.cpp -o MultiFile.<exe/out>. The former only compiles and links
  listed files, while the latter compiles and links all .cpp files in the directory. Both outputs will be named MultiFile.<exe/out>

- Header files should also be included in their paired .cpp files, to stop simple errors from occuring. In MultiFile, this means it should
not only be included in fileOne.cpp, but also fileTwo.cpp.

- Using #include <x> will tell the preprocessor to check the include directories for a file we did not write. Using "x" will check\
  right next to the .cpp/.h files for a file we DID write.

- Header sorting should be as such:
  - Paired header (in add.cpp, #include "add.h")
  - Other headers of the same project (in x.cpp, #include "y.h")
  - 3rd party headers (in x.cpp, #include <boost/tuple/tuple.hpp>)
  - Standard library headers: (in x.cpp, #include <iostream>)

- Header File Best Practices:
  - Always include header guards
  - Do not define variables/functions (for now)
  - Paried .cpp and .h files should be named the same i.e. x.cpp and x.h
  - Do not include .cpp files