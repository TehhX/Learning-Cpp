- Use direct-list initialization: int x { value }; for various reasons including:
  - Value Must be of type int (or whatever the data type is), or compiler will give an error (Easier to bug-fix)
    i.e. int x {4.5} will give an error, 4.5 is not an integer
  - Is the current/modern standard
  - Does not involve copying data, more effecient
  - Value initialization is of same format, i.e. x = {}; will set x to 0, thus easier to remember
    
- Can use extraction/insertion operators more than once
  - i.e. cin >> x >> y >> z; will take values seperated by spaces and put them into x, then y, then z.

- Declared variables are not initialized to any default values (unlike Java). int x; will not assing value 0 to x, x will be unassigned.

- Statements like x = 5 use the expression 5, which has the return value of 5, and side effect of assigning 5 to x.

- Main function always returns 0 implicitly (excluding error occurances obviously), so there is no need to put return 0; at the end.

- Can place a function below main() so long as you use forward declaration. For the function int add(int x, int y) {...}, just declare it before
  main as int add(int, int); so that main can call the actual function below it. No parameter names are required in the declaration, just types.
  However, naming them anyway is best practice. Use of forward declarations:
  - Circular-referencing functions. If two functions call each other, it is impossible to bring both of them behind the other, given the
    restrictions of spacetime.

  - Functions of other files. One cannot reorder the functions behind main when they exist in seperate files.

  - To help better organize code. If one wants to group functions, or sort them in a specific manner, forward declaration may be used.

- Dont use 'using namespace', specifically declare what namespace you mean at execution (i.e. std::cout)

- Macros can be used with the preprocessor. #define CAT DOG will replace all instances of CAT with DOG. It is unsafe, and reccomended against.

- Macros CAN however be safely used for things shown in https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/

- Header files (example.h) can be used to insert many common lines of code or forward declarations into the start of a .cpp file with the
  #include preprocessor directive. As for forward declarations, write them just the same as you would in the .cpp file. An example of this
  and multi-file organization in general can be found in /MultiFile. The files within can be compiled and linked by typing either
  "g++ fileOne.cpp fileTwo.cpp -0 MultiFile.<exe/out>" or "g++ *.cpp -o MultiFile.<exe/out>. The former only compiles and links
  listed files, while the latter compiles and links all .cpp files in the directory. Both outputs will be named MultiFile.<exe/out>

- Header files should also be included in their paired .cpp files, to stop simple errors from occuring. In MultiFile, this means it should
not only be included in fileOne.cpp, but also fileTwo.cpp.

- Using #include <x> will tell the preprocessor to check the include directories for a file we did not write. Using "x" will check\
  right next to the .cpp/.h files for a file we DID write.

- Header sorting should be as such:
  - Paired header (in add.cpp, #include "add.h")
  - Other headers of the same project (in x.cpp, #include "y.h")
  - 3rd party headers (in x.cpp, #include <boost/tuple/tuple.hpp>)
  - Standard library headers: (in x.cpp, #include <iostream>)

- Header File Best Practices:
  - Always include header guards
  - Do not define variables/functions (for now)
  - Paried .cpp and .h files should be named the same i.e. x.cpp and x.h
  - Do not include .cpp files

- Header guards help to stop duplicate declaration and initialization of functions and/or varaibles etc. They are simple to implement, just add
  a #define at the start of header files with a unique name. The name, by standard convention, is the name of the header file in all uppercase
  with underscores between words, and an H at the end. i.e. for a file named headerFile.h, use the definition #define HEADER_FILE_H. For the guard itself,
  use the following (for a file named headerFile.h):
    #ifndef HEADER_FILE_H
    #define HEADER_FILE_H
    // The header file itself, such as forward declarations, other includes, etc.
    #endif
  The code between #ifndef and #endif will only run if HEADER_FILE_H has not yet been defined. HEADER_FILE_H will be defined inside. This makes sure that
  the ODR (One Definition Rule) is not left unfollowed, and certain compile/runtime errors are not made. "#pragma once" also works in place of a traditional
  header guard in modern compilers, and is what most use (other than the old-heads at Google):
    #pragma once
    // The header file itself, such as forward declarations, other includes, etc.

- One can debug programs by adding the debugging lines of code, whatever they may be, and then only passing them through the preprocessor if a certain term is
  defined. For example, if one wants to only print out a line of code Line(); when debugging, one can place #ifdef ENABLE_DEBUG before, and #endif after. Then,
  these lines will only be passed through and compiled when the uncommented line of code #define ENABLE_DEBUG is present at the top of the file. This allows the
  inclusion and exclusion of certain lines of code, in this case debugging code, to only be compiled when that first line of code, #define ENABLE_DEBUG is present.
  Example (std::cerr... will only be compiled if #define ENABLE_DEBUG is present and NOT commented out): 

    #define ENABLE_DEBUG // comment out to disable debugging

    int getUserInput() {
      #ifdef ENABLE_DEBUG
      std::cerr << "getUserInput() called\n";
      #endif

      std::cout << "Enter a number: ";
      int x{};
      std::cin >> x;
      return x;
    }

 - Using a logger is also a possibility, like using <plog>. After initialization in main() via "plog::init(plog::debug, "Logfile.txt");" It will document any output by
   way of using "PLOGD << <output-string>;, i.e. "PLOGD << "Function Called";" NOTE: PLOG IS NOT INSTALLED BY DEFAULT, MUST BE DOWNLOADED FROM WEBSITE AND PLACED
   WITHIN INCLUDE FOLDERS! IT IS ALSO NOT THE ONLY LOGGER THAT EXISTS!

 - Using an integrated debugger is also an option, like the one in VS Code. I skipped many chapters on integrated debuggers, go back to 3.xx to reread later if it becomes pertinent.

 - 