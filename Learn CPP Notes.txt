- Use direct-list initialization: int x { value }; for various reasons including:
  - Value Must be of the given type, or compiler will give an error i.e. int x {4.5} will give an error, 4.5 is not an integer
  - Does not involve copying data, more effecient
  - Value initialization is of same format, i.e. x = {}; will set x to 0, thus easier to remember

- Can use extraction/insertion operators more than once, i.e. cin >> x >> y >> z; will take values seperated by whitespace and put them
  into x, then y, then z.

- Declared variables are not initialized to any default values (unlike Java). int x; will not assing value 0 to x, x will be unassigned.

- Statements like x = 5 use the expression 5, which has the return value of 5, and side effect of assigning 5 to x.

- Main function always returns 0 implicitly (excluding error occurances obviously), so there is no need to put return 0; at the end.

- Forward declarartions can be used for many things, by simply writing "T func(T, {etc.});" without the definition.
  - Circular-referencing functions. If two functions call each other, it is impossible to bring both of them behind the other, given the
    restrictions of spacetime.
  - Functions of other files. One cannot reorder the functions behind main when they exist in seperate files.
  - To help better organize code. If one wants to group functions, or sort them in a specific manner, forward declaration may be used.

- Dont use 'using namespace', specifically declare what namespace you mean line-by-line i.e. std::cout

- Macros can be used with the preprocessor. #define CAT DOG will replace all instances of CAT with DOG. It is unsafe, and reccomended agains

- Header files (example.h) can be used to insert many common pieces of code into multiple .cpp files such as:
  - Forward declarations
  - Common standard libraries
  - Templates
  - Global variable and function definitions

- Header files should also be included in their paired .cpp files, to stop simple errors from occuring. In MultiFile, this means it should
  not only be included in fileOne.cpp, but also fileTwo.cpp. If function types from forward declaration to definition are mismatched, the
  compiler will only complain if this practice is followed.

- Header sorting should be as such:
  - Paired header (in add.cpp, #include "add.hpp")
  - Other headers of the same project (in x.cpp, #include "y.hpp")
  - 3rd party headers (in x.cpp, #include <boost/tuple/tuple.hpp>)
  - Standard library headers: (in x.cpp, #include <iostream>)

- Header File Best Practices:
  - Always #pragma once
  - Paried .cpp and .hpp files should be named the same i.e. x.cpp and x.h
  - Do not include .cpp files

- Defining certain macros can make certain lines of code not compile with #ifdef for various purposes. Find an example
  in "/debugDefinition.cpp".

- Refactoring is the act of changing the code of a program without changing its behavior

- Numbers are signed by default (use the first bit to define positive/negative), but can be unsigned by using the keyword
  i.e. unsigned int x {5};

- The standard library allows fixed-width integers (Must "#include <cstdint>" All have "std::" prefix) Value ranges:
    - int8_t  = 1 byte signed    =                       -128 -> 127
    - uint8_t = 1 byte unsigned  =                          0 -> 255

    - int16_t  = 2 byte signed   =                    -32,768 -> 32,767
    - uint16_t = 2 byte unsigned =                          0 -> 65,535

    - int32_t  = 4 byte signed   =             -2,147,483,648 -> 2,147,483,647
    - uint32_t = 4 byte unsigned =                          0 -> 4,294,967,295

    - int64_t  = 8 byte signed   = -9,223,372,036,854,775,808 ->  9,223,372,036,854,775,807
    - uint64_t = 8 byte unsigned =                          0 -> 18,446,744,073,709,551,615

- Append 'f' to a number to ensure it is of float type instead of the implied double i.e. "5.0" is a double, "5.0f" is a float.

- Use "#include <iomanip>" and "std::cout << std::setprecision(int);" where int is the digits of precision for all future
  instances of "std::cout << {...}". Using more precision than is allowed by a data type will result in undefined digits
  after the actual precision ends. To have precision only affect post decimal digits, use "std::cout << std::fixed;" before
  "setprecision".

- Booleans will be printed by default as 1's and 0's, but the following command "std::cout << std::boolalpha;" will ensure all printing that
  occurs after will be printed as true's and false's. "std::cout << std::noboolalpha;" can be inversely used to revert back to 1's and 0's.

- When entering a boolean value by way of "std::cin >> bool;", it must be entered as 0's or 1's, any other value (inluding words like
  true or false) will default to false (or 0). This can be changed by the statement: "std::cin >> std::boolalpha;", which will allow
  (case-sensitive) "true" or "false" as input. However, it will NO LONGER accept 0's or 1's as input.

- If the program expects a boolean (i.e. if (bool) doThis();), an integer can be entered instead, where all non-zero values will be
  true, and 0 will be false.

- Explicit static casting can be done as such: "static_cast<T>(expression)" i.e. "static_cast<int>(5.5)" will cast the double "5.5"
  to an integer "5".

- Defining a constant variable goes as such: "const int {50};". The const should always go to the left of the type by convention.
  Varaibles that won't be changed should be made constant. This removes the potential for error in regards to the variable, lets the
  compiler optimize the code now that it knows the variable won't change, and reduces the complexity of a program.

- Defining a constant variable can also be done with "constexpr". This will generate a compile-time error if it is not actually constant,
  as well as whatever it is being defined as being constant itself. Whenever you can use "constexpr" over "const", do. For some cases
  however, "const" is the only/better choice.

- Literals are values inserted directly into code, without names. In the following definition "int x {5}", x is NOT a literal, as it is a
  variable. The '5' is is assigned to IS a literal, as it is an unnamed value. X has the name x, so it is not literal.

- One may have the following issue: "float x { 1.6 };" gives an error, as "1.6" is seen as a literal of type double. One can either change
  x from type float to type double, ergo "double x { 1.6 };", or change the input to a float, "float x { 1.6f };".

- Writing in scientific notation is allowed by way of using exponents. Writing 1,000,000 can also be done as 1e+6 or 1e6. 0.000001 can
  also be written as 1e-6.

- Other bases can be used. Writing in octal can be done by writing a zero before the octal i.e. 012 will be equal to 10. Writing in
  hexadecimal can be done with the prefix "0x" instead of '0'. i.e. 0xFFF is equal to 4095 decimal. Binary numbers can be written by the
  prefix "0b". i.e. 0b1111 = 15.

- Using C-style strings is dangerous, and may sometimes produce undefined behavior. Using "std::string" of "#include <string>" is prefered
  in cases where the string itelf is not literal. It allows string lengths to be changed, new values to be copied over, and is safer in
  general. However, things change when asking for input. "std::cin" will break operation on whitespace, potentially breaking a program.
  In this case, "std::getline()" is preferable. There are arguments that must be passed however. If one is trying to pass the input to a
  "std::string"-style string with variable name "name", write "std::getline(std::cin >> std::ws, name)". This passes the input as the first,
  and the variable to copy data to as the second. This will take the whole line, and work as expected, just like before with the C-style
  string. The first argument technically only needs the "std::cin", but one may add the ">> std::ws" to specify that leading whitespace
  should be removed. i.e. "    x" -> "x", but "x   " does not change (whitespace is not leading).

- Add an 's' after a string literal to change it to a std::string literal. i.e. <"Hello"> is a C-Style literal, <"Hello"s> is an std::string
  style literal.

- One can use std::string_view to create a read-only version of a string literal.

- User defined namespaces can be used to reduce collisions of functions and variables. Done as:
    namespace NamespaceName {
      int variableOne {valueOne};
      void doSomething(int x, int y) {
        // something to do
      }
    }
  Namespaces should have every first letter be capitalized i.e. "Namespace" instead of "namespace"

- Functions and variables in namespaces must be called with either a scope resolution operator i.e. for a function named "doSomething()"
  in namespace "Example" one would call "doSomething()" by using "Example::doSomething()". If it is being called from within the same
  namespace, the operator is not required. But if the callee is in the global namespace and one tries calling it from within a namespace,
  the global scope can be ensured by using the scope resolution operator without a prefix, i.e. global function "doSomething()" can be called
  from namespace "Example" using the statement "::doSomething()". Without a namespace specified, it means the global scope.

- Forward declarations in header files also need to be in the same namespace as their corrosponding definition. i.e. for function
  "ExampleNamespace::doSomething()" declared in "foo.cpp", if one wants to call it from "bar.cpp" with a header file, the namespace
  "ExampleNamespace" has to be used in the header file. Find an actual example in Learning-Cpp/NamespaceHeader.

- The same namespace can be declared across multiple files, and all within will be considered of the same namespace.

- Namespaces can also be declared within other namespaces. i.e. for a parent namespace "Foo", child namespace "Bar", and function in namespace
  "Bar" named "doSomething()", in the global namespace or a completley seperate namespace, the function would be called as
  "Foo::Bar::doSomething()".

- Namespace aliases can be used to shorten the calling of certain namespaces. i.e. for the same example as before, using
  "namespace FoobarShortened = Foo::Bar;". from then on, "Foo:Bar::doSomething()" can be called as "FoobarShortened::doSomething()". Obviously,
  this actually lengthens the scope resolution, but if we name it something shorter it can be made more concise.

- "std::swap" can be used with "#include <utility>". If one wants to swap variables 'x' and 'y', do: "std::swap(x, y);".

- The "static" keyword can be used to make variables and functions only link within the file it is in, no other files can use it. Constexpr
  variables are static by default, but can be made usable with other files by the "extern" keyword. Integers without the "constexpr" are
  external by default, and can be made static. Static variables and functions use internal linkage, and extern(al) variables/functions use
  external linkage.

- The "inline" keyword can be used when defining variables or functions in header files. This keyword will allow multiple definitions of the same
  variable/function being included and duplicated into multiple .cpp files, so long as they are all identical. The compiler/linker will also
  remove duplicates at compile time.

- Find examples of declaring/defining/initializing variables and functions in header files within Learning-Cpp/HeaderConstants

- The many static keyword definitions:
  - Static Duration: Variables that are created on program start, and destroyed on program exit. For example, global variables have a static
    duration.
  - Global variables with a static prefix are made internally linked.
  - Local variables with the static prefix will be created at the start of the program, and destroyed at program exit. This is just like how
    un-prefixed global variables work. However, these local variables will only be initialized once, so as to avoid errors. An example can be
    found at "Learning-Cpp/Assorted/staticVariables.cpp". These static-local variables can be used to generate a new copy of an integer/other
    type every function call, while keeping track of what increment the variable should be.

- Constexpr if statements can be used if constexpr variables defined before are a part of the condition, see "/constexprIf.cpp".

- Don't indent switch statement cases i.e.
    switch (value) {
    case x:
      doX();
      return;
    case y:
      doY():
      [[fallthrough]];
    default:
      doDefault();
    }

- The fallthrough statement can be used to indicate intentional fallthrough. Place "[[fallthrough]]" at the end of a case. Example in last
  point. It doesn't do anything other than show that fallthrough is intentional, and potentially disable some compuler warnings, as the
  code will execute just the same without it.

- The "goto" keyword can jump to a particular part of the program by a label. An example can be found in "/gotoBackwards.cpp".
  The goto label can also jump forwards, found in "/gotoForwards.cpp". Goto statements do not need to be declared by the time they're
  called, like variables and functions do. Goto statements are generally unused, but have some niche uses.

- Modulus usage example in "/fizzBuzz.cpp".

- The "continue" keyword can be used to break out of the current iteration of a loop statement, but continue to loop through it starting at
  the next index, or beginning. This keyword is used similarly to the "break" keyword, but doesn't completely exit the loop.

- A running program can be called before main() ends by using "#include <cstdlib> {...} std::exit();" Also, "std::atexit(func);" will
  call "func", and then exit the program as "std::exit();" does after "func" completes.

- Random numbers in C++ can be generated using multiple functions from "#include <random>". First, a random number for the seed needs to be
  picked or otherwidse generated. A single random number can be taken from "std::random_device", and put into the Mersenne Twister algorithm.
  It should be input multiple times (8 minimum) to help seed the MT algorithm. A uniform integer distributor can be used to distribute random
  numbers taken from this algorithm, and distribute the numbers between a minimum and maximum. Multiple different distributors can be used with
  the same RNG. An example of an RNG can be found in "/randomNumber.cpp".

- Assertive statements with "#include <cassert>" can detect problems and end the program. Regular assertions i.e. "assert(<true_thing>);" can
  become more descriptive, i.e. "assert(true && std::string);" will print to the console what was false, and the string passed to it. This
  helps with error logging. However, asserts should not be used in production code, only to help with debugging. 

- Static assertive statements can be used to evaluate code at compile time, without needing an "#include" header.
  "static_assert(true, string);". It requires a constexpr as the "true" however.

- There are multiple different explicit ways to cast a variable or literal. These include C and C++ style casts. C++ style casts have the
  benefit of being named, and being more specific. C style casts may also perform differently than expected. Check the following table:
    - C-Style Casts:
      - "(T) x"
      - "T(x)"
    - C++-Style Casts (In order of what the C-style cast tries to do):
      - "const_cast<T>(x)"
      - "static_cast<T>(x)"
      - "reinterpret_cast<T>(x)"
      - "dynamic_cast<T>(x)" (C-Style cast does not try to dynamic_cast at any point AFAIK)
      
- Implicit type conversion is done by the compiler without instruction from the programmer.

- Aliases can be created with the "using" keyword i.e. "using <new_key> = <old_key>;". They can also be included with a header file, as they
  will be declared in the global namespace of all ".cpp" files that include the header file. This is useful for shortening long type names.

- Functions with parameters may have default arguments for any or all of the parameters. The argument MUST be defined with the copy operator
  "=", direct-list initialization and others won't work. See "/defaultArguments.cpp".

- Templates are a functionality in C++ for creating reusable functions that can take multiple different types for a single parameter.
  - Certain input types can be deleted with the "= delete;" suffix, replacing all type placeholders with whatever should not be allowed.
  - Local static keywords will not keep their value between different type implementations of the template. This is because the compiler makes
    different functions for the template when they are required, and they initialize different variables.
  - Templates can have multiple wildcard types. When returning a value from multiple types, the auto keyword can be useful. It will deduce the
    correct type, and return it as such.
  - Template definitions in header files don't need the inline keyword as regular functions do.

- When compiling multiple files, start with the .cpp file that has the main function in it, or else the compiler will throw an error.

- Creating a constexpr variable requires the initializing variable to be a constant or literal itself. That means that functions aren't allowed
  as the input. This is where constexpr functions come into play. Find an example of its usage in "/constexprFunc.cpp".

- LValue references can be used to reference an existing variable and make somewhat of an alias of it. Reference variables MUST be initialized
  on declaration, it cannot be left null. Find an example in "/lvalueRef.cpp".

- LValue references cannot initialize and reference to:
  - Const vars, when the reference itself is not also const
  - RValues, like Literals

- LValues cannot be changed to reference another value or variable. Example in same file as before.

- References and the variables they're referencing have independent life times. References becoming deleted before their accompanying originals
  can occur in certain circumstances, but the original is not impacted. However, the original becoming deleted before the reference does impact
  the reference, leading to undefined behavior. This is called a dangling reference.

- References are not objects, and will be replaced by their referent at compile time where possible.

- References can be made constant when their originals are mutable, and the program will still work as expected. However, references cannot
  edit the original, so this makes things a bit safer. Editing the original will change the reference, even if the reference is const.

- Constexpr references need either a global variable, or a local static variable.

- Passing by value and passing by reference are two different things. They both refer to arguments inserted into function parameters, however
  what they pass are different. When passing by value, the object argument is copied onto the parameter in the function, and the function runs.
  This is fine for primitive types, but for classes and more expensive types, passing by reference is cheaper to run. Find an example in
  "/passByRef.cpp".

- Passing by value also differs to reference in terms of what can be edited in the function. Passing by value allows one to edit a copy
  of the passed value or class object etc, leaving the original intact. While this is desirable a lot of the time, passing by reference
  alows the original to be directly edited, which is just as useful. Same place for example.

- When passing a const by reference, the parameter must also be const. Same place again for example.

- An object is cheap to copy if it uses the size of <= 2 memory addresses.

- "std::string_view" is cheaper to copy and easier to work with than "const std::string&" in parameters.

- The address of operator, "&", can be placed before a variable to get its address in memory. The dereference operator, "*", can be
  placed before a memory address to get the value at the address. Find an example of both (with undefined behavior) in
  "/addressOperators.cpp". When the variable that the "address of" operator is referencing has more than one byte, it
  gives the address of the first byte.

- Pointers can be used to point to the address of an object in memory. Pointers, like other variables, must be initialized to a value,
  or else they will give garbage out. When a pointer is initialized with an empty direct-list initialization, it will be a null-pointer.
  Find an example in "/pointers.cpp".

- Pointers that point to an object that no longer exists are dangling pointers, very similar to dangling references.

- Null-pointers, mentioned previously, are pointers that don't point to any value. Attempting to print the value will lead to undefined
  behavior, g++ gives a segfault error. Example in "/nullPointers.cpp".

- Pointers that become dangling should always reach the end of their lifetime, or be set to nullptr. Dangling pointers themselves should
  exist for the shortest amount of time possible in any case. This allows one to assume any "!= nullptr" pointer is valid and not dangling,
  and that any "== nullptr" pointer is null (obviously).

- Older code might use outdated ways of assigning a pointer to null i.e. "T* x {0}", "T* x {NULL};" instead of the modern "T* x {nullptr};"

- Pointers of a non const type cannot point at a const type. The type of a pointer must be made const to point at a const type. This means
  that the pointer cannot modify the const variable. Pointers of a const type i.e. "const int" can point at a non const variable i.e "int".
  The pointer, however, still cannot modify the variable it points at, whether the variable is const or not. Example in
  "/constPointers.cpp".

- Pointers themselves, not the type they point at, can also be const. This changes it so that the pointer cannot be reseated. However, a
  const pointer can still be dereferenced to change the value at the address. This means that the only thing that is different about
  const pointers is the fact that they cannot change what they are pointing at.

- Note the difference between a pointer to a constant type and a constant pointer to a type, both in how they work and how their syntax
  differ from one another.

- Another way to pass through a parameter is by address (in addition to value and reference from before). Example in 
  "/passByAddress.cpp"

- Prefer pass by reference to pass by address when possible. Avoids null-pointer errors. If using pass by address, place "assert(ptr)"
  at the start of the function to make sure the program says when a null-pointer is accidentally passed. There are scenarios when a
  null pointer is acceptable/wanted when assert shouldn't be used.

- A function with a pointer default argument can have that default argument as nullptr. Then, within that function, certain things can
  be done if the pointer is null. Function overloading is often better, though.

- Passing an address creates a copy of the pointer, meaning that the original pointer passed as the argument cannot be changed within
  the function, such as changing what it points at (but what it points at CAN be changed). To change the original pointer from within
  a function, the address must be passed by reference. Example at "/passAddressByRef.cpp".

- Returning by reference is often less expensive than returning by value. It just requires the return reference to outlive the
  function. Placing const before the return type does nothing special at runtime, but helps to prevent bad code. Example in
  "/returnBy.cpp".

- If a parameter is passed by reference, it can safely be returned as a reference because its lifetime will exist outside of the
  function's scope.

- Functions that return a reference can be used as the LHS of an operation. Example in "outParameters.cpp".
  Out parameters can also be used to modify variables that exist outside of the scope of a function.

- Prefer returning by reference over by pointer, unless it is important to have returning nullptr as a possibility.

- Out parameters should be avoided unless they truely are the best option for a given issue.

- Optional objects can be returned instead of their regular counterparts if an error is possible to occur inside the function.
  Example in "optionals.cpp".

- Prefer passing by const T& instead of T& when possible, as more things are possible with constant reference values as parameters.

- User defined types like enumerations and classes can be used for compound data types that are not defined by Cpp.
  Example in "basicStruct.cpp" and "basicEnumerator.cpp".

- Place enumerators inside their own namespaces. Example in "namespacedEnumerator.cpp"

- Enumerators can have assigned values inside of them. Any unassigned enumerations inside of an enum that also contains assigned
  enumerations will always continue from the last enumeration. More than one enumeration can be assigned the same number, even if
  it is just the same number as an unassigned enumeration. Examples in "assignedEnumerator.cpp". 

- Enumerators have a base type, usually of type "int". However, they can be speicified at the enum header. Example in
  "enumBaseTypes.cpp"

- Maybe prefer unnamed enums inside namespaces if the namespace only contains the enum itself. Example in "simpleEnumScopes.cpp"

- Default (first/0) enum values should be the value seen as the defualt, or as close to what the default is as can be.

- Enums should always have a specified base type, even if it is just "int". Example with reason why in "enumTypeConversions.cpp"

- Enums can be converted to and from strings. Example in "enumStringInput.cpp".

- Scoped or class enums can be used for better encapsulation and type safety. They also have to be cast to whatever type is needed,
  as implicit conversion doesn't occur like with unscoped enums. Example in "scopedClassEmums.cpp"

- Structs can function as basic classes. When initializing a struct, initialization goes in top-down order. Uninitialized values will
  be set to either an undefined value, or their default value. They can also have a default value.

- Structs can be passed to and from functions. Structs can also be only used once. Structs can also be returned. 
  Examples in "passReturnStruct.cpp".

- Structs are optimized by compilers depending on member type and declaration order. List struct members from top to bottom in decreasing
  size order.

- When using pointers to take or change member values in an already initialized struct variable, the var must be dereferenced as usual
  with pointers. Arrow notation can be used instead when the struct is a pointer instead of dereferencing inside parenthesis.
  Example in "pointerStructs.cpp". The arrow notation is formally called the "member selection from pointer operator".

- Structs can also use templates, much like functions can.

- Structs made in C++17 need to have guides on how to auto assume types without needing the diamond operators. Example in 
  "triadStruct.cpp".

- Classes can also be used in place of structs for more complex types. They allow encapsulation with different access modifiers.
  Most of the standard library is comprised of classes.

- Both structs and classes can have member functions, as I have written in previous example files like "triadStruct.cpp"

- The typical C++ declaration order from top to bottom doesn't apply for classes, so variables and functions can be declared/defined
  in any order. However, members that initialize using another member of the same object that is itself initialized later will result
  in undefined behavior.

- General rule of thumb states that structs should only have member-variables, while classes may have member functions as well. However,
  both structs and classes technically have the same ruleset. The only difference is that structs default to public member access,
  while classes default to private.

- Structs and classes can be made const just like other types, which means that none of their member variables may be changed. It also
  means that non-const member functions may not be called from the const object. However, a "const" may be appended after the parameter
  parenthesis and before the opening brace of a function to turn the function itself const. This assures the compiler that it doesn't
  change any member variables, and it may be called even if the object is const. Given that const functions can be used no matter the
  case, any function that fits the above criteria should be made const.

- A member function being const or not will allow it to be overloaded with the other. This is very rare.

- In java, when an instance variable and passed variable have the same name, the "this" keyword is used. In C++, it works as seen in
  the "isEqual" function inside "intPair.cpp" using the arrow notation.

- See an example of classes, const functions, the "this->x" keyword/notation, and access modifiers in "3dPointClass.cpp".

- Classes need constructors for private members just like Java. Members should be initialized using the member initialization list
  method. Example at "classConstructors.cpp".

- Classes can have overloaded constructors, or constructors with default arguments. Constructors can also have default constructors
  using "class_name() = default". Example in "ball.cpp"

- Classes can delegate to other constructors in the member list initialization. Example at "ball.cpp"".

- Temporary class and/or fundamental objects can be created with "class_name var_name {value}". Example in "copyConstructor.cpp".

- Copy constructors can be used to create a new class object of type T using a previously defined class opject of type T. The
  implicit copy constructor usually does exactly what is required, and should thus be used most of the time. Copy constructors
  can also be specifically omitted using the "delete" keyword. Example at "copyConstructor.cpp".

- Copy elision may be performed by the compiler to optimize away unnessessary object copying. This is why the copy constructor
  should not have side-effects.

- An aggregate is a class type (struct, class etc.) that has no member functions, no constructors and no access modifiers (unsure).

- Member functions can be chained together by returning their class object using the "this" keyword. Example in "thisObject.cpp"

- Class objects can be **reset** by setting their class object to the default state. Example in "thisObject.cpp".

- Large classes should get their own .cpp and .hpp files. .hpp files should only declare, while the associated .cpp file should define.
  For these large classes, only single line member functions should be defined inside the class itself, while the rest should be
  defined outside using the "::" operator. I have tried to demonstrate every detail on how to create class files in "ClassFiles/*".

- Type enums that are only used for a single class should be declared within the class at the top within a seperate "public:" tag.
  Example in "ClassFiles/person.hpp".

- Destructors can be used to perform some action when a class dies. They are made using the same syntax as a constructor, but takes
  NO parameters, has NO return type, and must be preceeded by a tilde (~). Find an example in "destructors.cpp".

- Classes may be made templated, so long as any member functions defined outside also use the template preline. Example in
  "templateClass.cpp".

- Static member variables may be used similarly to local static variables. Example in "staticMembers.cpp".

- The "friend" keyword can be used to allow a function to access private variables of a class. This is often a bad approach.

- Friend classes are made in the same way as friend functions, by adding the "friend" keyword to the declaration within the friend
  class.

- Ref qualifiers can be used to overload functions with both a r-value and l-value friendly return value. Example in "refQualifier.cpp".
  They are not reccomended.

- Vectors are a container type that can hold many values. Define them using "{value1, value2, ...}". To make an empty vector array,
  use direct initialization where n is the size of the array, "std::vector var (n);"

- Arrays can be returned by value due to move semantics.

- Using "array.size()" gives the size of the array.

- With vectors, many things can be done to modify them. Examples of all in "vectorModification.cpp".

- Boolean vector arrays are problematic to work with. Use char vectors instead, or bitsets if values are known beforehand.

- If the content or length of an array is known in its entirety at compile time, use an "std::array". The bonus of arrays when
  compared to vectors is that they may be made const or constexpr.

- Array lengths of std::array's can be returned as constexpr values as unsigned ints.

- The integral type of std::array length values are "std::size_t".

- Arrays of references are not allowed, but arrays of reference wrappers are. Example in "refWrappedArray.cpp".

- Pointer arithmatic may be used to manually change the address of a pointer by the size of the type that the pointer points to.
  Example in "pointerMath.cpp".

- Multidimensional arrays and vectors are supported. Example in "multiDimArray.cpp".

- Array iterators example in "iterators.cpp".

- Void pointers can be used to point to any data type, and reassigned to a different or same type. Example in "voidPointers.cpp"

- Pointers can point to functions. Example in "funcPointers.cpp"/

- Cpp files can take command line arguments using a special main function. Example in "commandLineArguments.cpp".

- Lambdas can be used as anonymous functions. Example in "lambdas.cpp".

- Lambdas can only access variables in their scope. To "capture" variables from inside its parent scope, use the "[]" capture
  clause.
  - You cannot change a captured variable without declaring the lambda as "mutable" after the () and before the {}.
  - Lambda captures are copies. To capture by reference, use "[&variableName]" in place of "[variableName]"
  - To capture all variables in the parent scope, use "[=]" for copy, and "[&]" for reference.
  - To capture multiple particular variables, comma seperate them.